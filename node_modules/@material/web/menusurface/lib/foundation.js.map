{"version":3,"file":"foundation.js","sourceRoot":"","sources":["foundation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {MDCMenuSurfaceAdapter} from './adapter.js';\nimport {Corner, CornerBit, cssClasses, numbers, strings} from './constants.js';\nimport {MDCMenuDimensions, MDCMenuDistance, MDCMenuPoint} from './types.js';\n\ninterface AutoLayoutMeasurements {\n  anchorSize: MDCMenuDimensions;\n  bodySize: MDCMenuDimensions;\n  surfaceSize: MDCMenuDimensions;\n  viewportDistance: MDCMenuDistance;\n  viewportSize: MDCMenuDimensions;\n  windowScroll: MDCMenuPoint;\n}\n\nexport class MDCMenuSurfaceFoundation {\n  static get cssClasses() {\n    return cssClasses;\n  }\n\n  static get strings() {\n    return strings;\n  }\n\n  static get numbers() {\n    return numbers;\n  }\n\n  static get Corner() {\n    return Corner;\n  }\n\n  /**\n   * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.\n   */\n  static get defaultAdapter(): MDCMenuSurfaceAdapter {\n    // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n    return {\n      addClass: () => undefined,\n      removeClass: () => undefined,\n      hasClass: () => false,\n      hasAnchor: () => false,\n\n      isElementInContainer: () => false,\n      isFocused: () => false,\n      isRtl: () => false,\n\n      getInnerDimensions: () => ({height: 0, width: 0}),\n      getAnchorDimensions: () => null,\n      getWindowDimensions: () => ({height: 0, width: 0}),\n      getBodyDimensions: () => ({height: 0, width: 0}),\n      getWindowScroll: () => ({x: 0, y: 0}),\n      setPosition: () => undefined,\n      setMaxHeight: () => undefined,\n      setTransformOrigin: () => undefined,\n\n      saveFocus: () => undefined,\n      restoreFocus: () => undefined,\n\n      notifyClose: () => undefined,\n      notifyClosing: () => undefined,\n      notifyOpen: () => undefined,\n      notifyOpening: () => undefined,\n    };\n    // tslint:enable:object-literal-sort-keys\n  }\n\n  private readonly adapter: MDCMenuSurfaceAdapter;\n  private isSurfaceOpen = false;\n  private isQuickOpen = false;\n  private isHoistedElement = false;\n  private isFixedPosition = false;\n  private isHorizontallyCenteredOnViewport = false;\n\n  private maxHeight = 0;\n  private openBottomBias = 0;\n\n  private openAnimationEndTimerId = 0;\n  private closeAnimationEndTimerId = 0;\n  private animationRequestId = 0;\n\n  private anchorCorner: Corner = Corner.TOP_START;\n\n  /**\n   * Corner of the menu surface to which menu surface is attached to anchor.\n   *\n   *  Anchor corner --->+----------+\n   *                    |  ANCHOR  |\n   *                    +----------+\n   *  Origin corner --->+--------------+\n   *                    |              |\n   *                    |              |\n   *                    | MENU SURFACE |\n   *                    |              |\n   *                    |              |\n   *                    +--------------+\n   */\n  private originCorner: Corner = Corner.TOP_START;\n  private readonly anchorMargin:\n      MDCMenuDistance = {top: 0, right: 0, bottom: 0, left: 0};\n  private readonly position: MDCMenuPoint = {x: 0, y: 0};\n\n  private dimensions!: MDCMenuDimensions;         // assigned in open()\n  private measurements!: AutoLayoutMeasurements;  // assigned in open()\n\n  constructor(adapter: Partial<MDCMenuSurfaceAdapter>) {\n    this.adapter = {...MDCMenuSurfaceFoundation.defaultAdapter, ...adapter};\n  }\n\n  init() {\n    const {ROOT, OPEN} = MDCMenuSurfaceFoundation.cssClasses;\n\n    if (!this.adapter.hasClass(ROOT)) {\n      throw new Error(`${ROOT} class required in root element.`);\n    }\n\n    if (this.adapter.hasClass(OPEN)) {\n      this.isSurfaceOpen = true;\n    }\n  }\n\n  destroy() {\n    clearTimeout(this.openAnimationEndTimerId);\n    clearTimeout(this.closeAnimationEndTimerId);\n    // Cancel any currently running animations.\n    cancelAnimationFrame(this.animationRequestId);\n  }\n\n  /**\n   * @param corner Default anchor corner alignment of top-left menu surface\n   *     corner.\n   */\n  setAnchorCorner(corner: Corner) {\n    this.anchorCorner = corner;\n  }\n\n  /**\n   * Flips menu corner horizontally.\n   */\n  flipCornerHorizontally() {\n    this.originCorner = this.originCorner ^ CornerBit.RIGHT;\n  }\n\n  /**\n   * @param margin Set of margin values from anchor.\n   */\n  setAnchorMargin(margin: Partial<MDCMenuDistance>) {\n    this.anchorMargin.top = margin.top || 0;\n    this.anchorMargin.right = margin.right || 0;\n    this.anchorMargin.bottom = margin.bottom || 0;\n    this.anchorMargin.left = margin.left || 0;\n  }\n\n  /** Used to indicate if the menu-surface is hoisted to the body. */\n  setIsHoisted(isHoisted: boolean) {\n    this.isHoistedElement = isHoisted;\n  }\n\n  /**\n   * Used to set the menu-surface calculations based on a fixed position menu.\n   */\n  setFixedPosition(isFixedPosition: boolean) {\n    this.isFixedPosition = isFixedPosition;\n  }\n\n  /**\n   * @return Returns true if menu is in fixed (`position: fixed`) position.\n   */\n  isFixed() {\n    return this.isFixedPosition;\n  }\n\n  /** Sets the menu-surface position on the page. */\n  setAbsolutePosition(x: number, y: number) {\n    this.position.x = this.isFinite(x) ? x : 0;\n    this.position.y = this.isFinite(y) ? y : 0;\n  }\n\n  /** Sets whether menu-surface should be horizontally centered to viewport. */\n  setIsHorizontallyCenteredOnViewport(isCentered: boolean) {\n    this.isHorizontallyCenteredOnViewport = isCentered;\n  }\n\n  setQuickOpen(quickOpen: boolean) {\n    this.isQuickOpen = quickOpen;\n  }\n\n  /**\n   * Sets maximum menu-surface height on open.\n   * @param maxHeight The desired max-height. Set to 0 (default) to\n   *     automatically calculate max height based on available viewport space.\n   */\n  setMaxHeight(maxHeight: number) {\n    this.maxHeight = maxHeight;\n  }\n\n  /**\n   * Set to a positive integer to influence the menu to preferentially open\n   * below the anchor instead of above.\n   * @param bias A value of `x` simulates an extra `x` pixels of available space\n   *     below the menu during positioning calculations.\n   */\n  setOpenBottomBias(bias: number) {\n    this.openBottomBias = bias;\n  }\n\n  isOpen() {\n    return this.isSurfaceOpen;\n  }\n\n  /**\n   * Open the menu surface.\n   */\n  open() {\n    if (this.isSurfaceOpen) {\n      return;\n    }\n\n    this.adapter.notifyOpening();\n    this.adapter.saveFocus();\n\n    if (this.isQuickOpen) {\n      this.isSurfaceOpen = true;\n      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n      this.dimensions = this.adapter.getInnerDimensions();\n      this.autoposition();\n      this.adapter.notifyOpen();\n    } else {\n      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n      this.animationRequestId = requestAnimationFrame(() => {\n        this.dimensions = this.adapter.getInnerDimensions();\n        this.autoposition();\n        this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n        this.openAnimationEndTimerId = setTimeout(() => {\n          this.openAnimationEndTimerId = 0;\n          this.adapter.removeClass(\n              MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n          this.adapter.notifyOpen();\n        }, numbers.TRANSITION_OPEN_DURATION);\n      });\n\n      this.isSurfaceOpen = true;\n    }\n  }\n\n  /**\n   * Closes the menu surface.\n   */\n  close(skipRestoreFocus = false) {\n    if (!this.isSurfaceOpen) {\n      return;\n    }\n\n    this.adapter.notifyClosing();\n\n    if (this.isQuickOpen) {\n      this.isSurfaceOpen = false;\n      if (!skipRestoreFocus) {\n        this.maybeRestoreFocus();\n      }\n\n      this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n      this.adapter.removeClass(\n          MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n      this.adapter.notifyClose();\n\n      return;\n    }\n\n    this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n    requestAnimationFrame(() => {\n      this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n      this.adapter.removeClass(\n          MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n      this.closeAnimationEndTimerId = setTimeout(() => {\n        this.closeAnimationEndTimerId = 0;\n        this.adapter.removeClass(\n            MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n        this.adapter.notifyClose();\n      }, numbers.TRANSITION_CLOSE_DURATION);\n    });\n\n    this.isSurfaceOpen = false;\n    if (!skipRestoreFocus) {\n      this.maybeRestoreFocus();\n    }\n  }\n\n  /** Handle clicks and close if not within menu-surface element. */\n  handleBodyClick(evt: MouseEvent) {\n    const el = evt.target as Element;\n    if (this.adapter.isElementInContainer(el)) {\n      return;\n    }\n    this.close();\n  }\n\n  /** Handle keys that close the surface. */\n  handleKeydown(evt: KeyboardEvent) {\n    const {keyCode, key} = evt;\n\n    const isEscape = key === 'Escape' || keyCode === 27;\n    if (isEscape) {\n      this.close();\n    }\n  }\n\n  private autoposition() {\n    // Compute measurements for autoposition methods reuse.\n    this.measurements = this.getAutoLayoutmeasurements();\n\n    const corner = this.getOriginCorner();\n    const maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);\n    const verticalAlignment =\n        this.hasBit(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';\n    let horizontalAlignment =\n        this.hasBit(corner, CornerBit.RIGHT) ? 'right' : 'left';\n    const horizontalOffset = this.getHorizontalOriginOffset(corner);\n    const verticalOffset = this.getVerticalOriginOffset(corner);\n    const {anchorSize, surfaceSize} = this.measurements;\n\n    const position: Partial<MDCMenuDistance> = {\n      [horizontalAlignment]: horizontalOffset,\n      [verticalAlignment]: verticalOffset,\n    };\n\n    // Center align when anchor width is comparable or greater than menu\n    // surface, otherwise keep corner.\n    if (anchorSize.width / surfaceSize.width >\n        numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {\n      horizontalAlignment = 'center';\n    }\n\n    // If the menu-surface has been hoisted to the body, it's no longer relative\n    // to the anchor element\n    if (this.isHoistedElement || this.isFixedPosition) {\n      this.adjustPositionForHoistedElement(position);\n    }\n\n    this.adapter.setTransformOrigin(\n        `${horizontalAlignment} ${verticalAlignment}`);\n    this.adapter.setPosition(position);\n    this.adapter.setMaxHeight(\n        maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');\n\n    // If it is opened from the top then add is-open-below class\n    if (!this.hasBit(corner, CornerBit.BOTTOM)) {\n      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n    }\n  }\n\n  /**\n   * @return Measurements used to position menu surface popup.\n   */\n  private getAutoLayoutmeasurements(): AutoLayoutMeasurements {\n    let anchorRect = this.adapter.getAnchorDimensions();\n    const bodySize = this.adapter.getBodyDimensions();\n    const viewportSize = this.adapter.getWindowDimensions();\n    const windowScroll = this.adapter.getWindowScroll();\n\n    if (!anchorRect) {\n      // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n      anchorRect = {\n        top: this.position.y,\n        right: this.position.x,\n        bottom: this.position.y,\n        left: this.position.x,\n        width: 0,\n        height: 0,\n      } as any;\n      // tslint:enable:object-literal-sort-keys\n    }\n\n    return {\n      anchorSize: anchorRect!,\n      bodySize,\n      surfaceSize: this.dimensions,\n      viewportDistance: {\n        // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n        top: anchorRect!.top,\n        right: viewportSize.width - anchorRect!.right,\n        bottom: viewportSize.height - anchorRect!.bottom,\n        left: anchorRect!.left,\n        // tslint:enable:object-literal-sort-keys\n      },\n      viewportSize,\n      windowScroll,\n    };\n  }\n\n  /**\n   * Computes the corner of the anchor from which to animate and position the\n   * menu surface.\n   *\n   * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL\n   * context. E.g., menu surface will be positioned from right side on TOP_END.\n   */\n  private getOriginCorner(): Corner {\n    let corner = this.originCorner;\n\n    const {viewportDistance, anchorSize, surfaceSize} = this.measurements;\n    const {MARGIN_TO_EDGE} = MDCMenuSurfaceFoundation.numbers;\n\n    const isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n\n    let availableTop;\n    let availableBottom;\n    if (isAnchoredToBottom) {\n      availableTop =\n          viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;\n      availableBottom =\n          viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;\n    } else {\n      availableTop =\n          viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;\n      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE +\n          anchorSize.height - this.anchorMargin.top;\n    }\n\n    const isAvailableBottom = availableBottom - surfaceSize.height > 0;\n    if (!isAvailableBottom &&\n        availableTop > availableBottom + this.openBottomBias) {\n      // Attach bottom side of surface to the anchor.\n      corner = this.setBit(corner, CornerBit.BOTTOM);\n    }\n\n    const isRtl = this.adapter.isRtl();\n    const isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);\n    const hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) ||\n        this.hasBit(corner, CornerBit.RIGHT);\n\n    // Whether surface attached to right side of anchor element.\n    let isAnchoredToRight = false;\n\n    // Anchored to start\n    if (isRtl && isFlipRtl) {\n      isAnchoredToRight = !hasRightBit;\n    } else {\n      // Anchored to right\n      isAnchoredToRight = hasRightBit;\n    }\n\n    let availableLeft;\n    let availableRight;\n    if (isAnchoredToRight) {\n      availableLeft =\n          viewportDistance.left + anchorSize.width + this.anchorMargin.right;\n      availableRight = viewportDistance.right - this.anchorMargin.right;\n    } else {\n      availableLeft = viewportDistance.left + this.anchorMargin.left;\n      availableRight =\n          viewportDistance.right + anchorSize.width - this.anchorMargin.left;\n    }\n\n    const isAvailableLeft = availableLeft - surfaceSize.width > 0;\n    const isAvailableRight = availableRight - surfaceSize.width > 0;\n    const isOriginCornerAlignedToEnd =\n        this.hasBit(corner, CornerBit.FLIP_RTL) &&\n        this.hasBit(corner, CornerBit.RIGHT);\n\n    if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl ||\n        !isAvailableLeft && isOriginCornerAlignedToEnd) {\n      // Attach left side of surface to the anchor.\n      corner = this.unsetBit(corner, CornerBit.RIGHT);\n    } else if (\n        isAvailableLeft && isAnchoredToRight && isRtl ||\n        (isAvailableLeft && !isAnchoredToRight && hasRightBit) ||\n        (!isAvailableRight && availableLeft >= availableRight)) {\n      // Attach right side of surface to the anchor.\n      corner = this.setBit(corner, CornerBit.RIGHT);\n    }\n\n    return corner;\n  }\n\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Maximum height of the menu surface, based on available space. 0\n   *     indicates should not be set.\n   */\n  private getMenuSurfaceMaxHeight(corner: Corner): number {\n    if (this.maxHeight > 0) {\n      return this.maxHeight;\n    }\n\n    const {viewportDistance} = this.measurements;\n\n    let maxHeight = 0;\n    const isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n    const isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n    const {MARGIN_TO_EDGE} = MDCMenuSurfaceFoundation.numbers;\n\n    // When maximum height is not specified, it is handled from CSS.\n    if (isBottomAligned) {\n      maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;\n      if (!isBottomAnchored) {\n        maxHeight += this.measurements.anchorSize.height;\n      }\n    } else {\n      maxHeight = viewportDistance.bottom - this.anchorMargin.bottom +\n          this.measurements.anchorSize.height - MARGIN_TO_EDGE;\n      if (isBottomAnchored) {\n        maxHeight -= this.measurements.anchorSize.height;\n      }\n    }\n\n    return maxHeight;\n  }\n\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Horizontal offset of menu surface origin corner from corresponding\n   *     anchor corner.\n   */\n  private getHorizontalOriginOffset(corner: Corner): number {\n    const {anchorSize} = this.measurements;\n\n    // isRightAligned corresponds to using the 'right' property on the surface.\n    const isRightAligned = this.hasBit(corner, CornerBit.RIGHT);\n    const avoidHorizontalOverlap =\n        this.hasBit(this.anchorCorner, CornerBit.RIGHT);\n\n    if (isRightAligned) {\n      const rightOffset = avoidHorizontalOverlap ?\n          anchorSize.width - this.anchorMargin.left :\n          this.anchorMargin.right;\n\n      // For hoisted or fixed elements, adjust the offset by the difference\n      // between viewport width and body width so when we calculate the right\n      // value (`adjustPositionForHoistedElement`) based on the element\n      // position, the right property is correct.\n      if (this.isHoistedElement || this.isFixedPosition) {\n        return rightOffset -\n            (this.measurements.viewportSize.width -\n             this.measurements.bodySize.width);\n      }\n\n      return rightOffset;\n    }\n\n    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right :\n                                    this.anchorMargin.left;\n  }\n\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Vertical offset of menu surface origin corner from corresponding\n   *     anchor corner.\n   */\n  private getVerticalOriginOffset(corner: Corner): number {\n    const {anchorSize} = this.measurements;\n    const isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n    const avoidVerticalOverlap =\n        this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n\n    let y = 0;\n    if (isBottomAligned) {\n      y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top :\n                                 -this.anchorMargin.bottom;\n    } else {\n      y = avoidVerticalOverlap ?\n          (anchorSize.height + this.anchorMargin.bottom) :\n          this.anchorMargin.top;\n    }\n    return y;\n  }\n\n  /**\n   * Calculates the offsets for positioning the menu-surface when the\n   * menu-surface has been hoisted to the body.\n   */\n  private adjustPositionForHoistedElement(position: Partial<MDCMenuDistance>) {\n    const {windowScroll, viewportDistance, surfaceSize, viewportSize} =\n        this.measurements;\n\n    const props =\n        Object.keys(position) as Array<keyof Partial<MDCMenuDistance>>;\n\n    for (const prop of props) {\n      let value = position[prop] || 0;\n\n      if (this.isHorizontallyCenteredOnViewport &&\n          (prop === 'left' || prop === 'right')) {\n        position[prop] = (viewportSize.width - surfaceSize.width) / 2;\n        continue;\n      }\n\n      // Hoisted surfaces need to have the anchor elements location on the page\n      // added to the position properties for proper alignment on the body.\n      value += viewportDistance[prop];\n\n      // Surfaces that are absolutely positioned need to have additional\n      // calculations for scroll and bottom positioning.\n      if (!this.isFixedPosition) {\n        if (prop === 'top') {\n          value += windowScroll.y;\n        } else if (prop === 'bottom') {\n          value -= windowScroll.y;\n        } else if (prop === 'left') {\n          value += windowScroll.x;\n        } else {  // prop === 'right'\n          value -= windowScroll.x;\n        }\n      }\n\n      position[prop] = value;\n    }\n  }\n\n  /**\n   * The last focused element when the menu surface was opened should regain\n   * focus, if the user is focused on or within the menu surface when it is\n   * closed.\n   */\n  private maybeRestoreFocus() {\n    const isRootFocused = this.adapter.isFocused();\n    const ownerDocument = this.adapter.getOwnerDocument ?\n        this.adapter.getOwnerDocument() :\n        document;\n    const childHasFocus = ownerDocument.activeElement &&\n        this.adapter.isElementInContainer(ownerDocument.activeElement);\n    if (isRootFocused || childHasFocus) {\n      // Wait before restoring focus when closing the menu surface. This is\n      // important because if a touch event triggered the menu close, and the\n      // subsequent mouse event occurs after focus is restored, then the\n      // restored focus would be lost.\n      setTimeout(() => {\n        this.adapter.restoreFocus();\n      }, numbers.TOUCH_EVENT_WAIT_MS);\n    }\n  }\n\n  private hasBit(corner: Corner, bit: CornerBit): boolean {\n    return Boolean(corner & bit);  // tslint:disable-line:no-bitwise\n  }\n\n  private setBit(corner: Corner, bit: CornerBit): Corner {\n    return corner | bit;  // tslint:disable-line:no-bitwise\n  }\n\n  private unsetBit(corner: Corner, bit: CornerBit): Corner {\n    return corner ^ bit;\n  }\n\n  /**\n   * isFinite that doesn't force conversion to number type.\n   * Equivalent to Number.isFinite in ES2015, which is not supported in IE.\n   */\n  private isFinite(num: number): boolean {\n    return typeof num === 'number' && isFinite(num);\n  }\n}\n"]}