{"version":3,"file":"observer.js","sourceRoot":"","sources":["observer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A function used to observe property changes on a target.\n *\n * @template T The observed target type.\n * @template K The observed property.\n * @template This The `this` context of the observer function.\n * @param current - The current value of the property.\n * @param previous - The previous value of the property.\n */\nexport type Observer<T extends object, K extends keyof T = keyof T,\n                                                 This = unknown> =\n    (this: This, current: T[K], previous: T[K]) => void;\n\n/**\n * An object map whose keys are properties of a target to observe and values\n * are `Observer` functions for each property.\n *\n * @template T The observed target type.\n * @template This The `this` context of observer functions.\n */\nexport type ObserverRecord<T extends object, This = unknown> = {\n  [K in keyof T]?: Observer<T, K, This>;\n};\n\nconst isTargetObservers = Symbol();\nconst isEnabled = Symbol();\nconst getObservers = Symbol();\n\n/**\n * A manager for observers listening to a target. A target's `prototype` is its\n * `TargetObservers` instance.\n *\n * @template T The observed target type.\n */\ninterface TargetObservers<T extends object> {\n  /**\n   * Indicates that the prototype is a `TargetObservers` instance.\n   */\n  [isTargetObservers]: true;\n\n  /**\n   * Indicates whether or not observers for this target are enabled. If\n   * disabled, observers will not be called in response to target property\n   * changes.\n   */\n  [isEnabled]: boolean;\n\n  /**\n   * Retrieves all observers for a given target property.\n   *\n   * @template K The target property key.\n   * @param key - The property to retrieve observers for.\n   * @return An array of observers for the provided target property.\n   */\n  [getObservers]: <K extends keyof T>(key: K) => Array<Observer<T, K>>;\n}\n\n/**\n * Observe a target's property for changes. When a property changes, the\n * provided `Observer` function will be invoked with the properties current and\n * previous values.\n *\n * The returned cleanup function will stop listening to changes for the\n * provided `Observer`.\n *\n * @template T The observed target type.\n * @template K The observed property.\n * @param target - The target to observe.\n * @param property - The property of the target to observe.\n * @param observer - An observer function to invoke each time the property\n *     changes.\n * @return A cleanup function that will stop observing changes for the provided\n *     `Observer`.\n */\nexport function observeProperty<T extends object, K extends keyof T>(\n    target: T, property: K, observer: Observer<T, K>) {\n  const observerPrototype = installObserver(target);\n  const observers = observerPrototype[getObservers](property);\n  observers.push(observer);\n  return () => {\n    observers.splice(observers.indexOf(observer), 1);\n  };\n}\n\n/**\n * Installs a `TargetObservers` for the provided target (if not already\n * installed).\n *\n * A target's `TargetObservers` is installed as a Proxy on the target's\n * prototype.\n *\n * @template T The observed target type.\n * @param obj - The target to observe.\n * @return The installed `TargetObservers` for the provided target.\n */\nfunction installObserver<T extends object>(obj: T): TargetObservers<T> {\n  const prototype = Object.getPrototypeOf(obj);\n  if (prototype[isTargetObservers]) {\n    return prototype as TargetObservers<T>;\n  }\n\n  // Proxy prototypes will not trap plain properties (not a getter/setter) that\n  // are already defined. They only work on new plain properties.\n  // We can work around this by deleting the properties, installing the Proxy,\n  // then re-setting the properties.\n  const existingKeyValues = new Map<keyof T, T[keyof T]>();\n  const keys = Object.getOwnPropertyNames(obj) as Array<keyof T>;\n  for (const key of keys) {\n    const descriptor = getDescriptor(obj, key);\n    if (descriptor && descriptor.writable) {\n      existingKeyValues.set(key, descriptor.value as T[keyof T]);\n      delete obj[key];\n    }\n  }\n\n  const proxy =\n      new Proxy<T>(Object.create(prototype), {\n        get(target, key, receiver) {\n          return Reflect.get(target, key, receiver);\n        },\n        set(target, key, newValue, receiver) {\n          const isTargetObserversKey = key === isTargetObservers ||\n              key === isEnabled || key === getObservers;\n          const previous = Reflect.get(target, key, receiver);\n          // If a key has an existing setter, invoke it with the receiver to\n          // preserve the correct `this` context.\n          // Otherwise, the key is either a new or existing plain property and\n          // should be set on the target. Setting a plain property on the\n          // receiver will cause the proxy to no longer be able to observe it.\n          const descriptor = getDescriptor(target, key as keyof T);\n          if (descriptor?.set) {\n            Reflect.set(target, key, newValue, receiver);\n          } else {\n            Reflect.set(target, key, newValue);\n          }\n\n          if (!isTargetObserversKey && proxy[isEnabled] &&\n              newValue !== previous) {\n            for (const observer of proxy[getObservers](key as keyof T)) {\n              observer(newValue, previous);\n            }\n          }\n\n          return true;\n        }\n      }) as TargetObservers<T>;\n\n  proxy[isTargetObservers] = true;\n  proxy[isEnabled] = true;\n  const observersMap = new Map<keyof T, Array<Observer<T>>>();\n  proxy[getObservers] = (key: keyof T) => {\n    const observers = observersMap.get(key) || [];\n    if (!observersMap.has(key)) {\n      observersMap.set(key, observers);\n    }\n\n    return observers;\n  };\n\n  Object.setPrototypeOf(obj, proxy);\n  // Re-set plain pre-existing properties so that the Proxy can trap them\n  for (const [key, value] of existingKeyValues.entries()) {\n    obj[key] = value;\n  }\n\n  return proxy;\n}\n\n/**\n * Enables or disables all observers for a provided target. Changes to observed\n * properties will not call any observers when disabled.\n *\n * @template T The observed target type.\n * @param target - The target to enable or disable observers for.\n * @param enabled - True to enable or false to disable observers.\n */\nexport function setObserversEnabled<T extends object>(\n    target: T, enabled: boolean) {\n  const prototype = Object.getPrototypeOf(target);\n  if (prototype[isTargetObservers]) {\n    (prototype as TargetObservers<T>)[isEnabled] = enabled;\n  }\n}\n\n/**\n * Retrieves the descriptor for a property from the provided target. This\n * function will walk up the target's prototype chain to search for the\n * descriptor.\n *\n * @template T The target type.\n * @template K The property type.\n * @param target - The target to retrieve a descriptor from.\n * @param property - The name of the property to retrieve a descriptor for.\n * @return the descriptor, or undefined if it does not exist. Keep in mind that\n *     plain properties may not have a descriptor defined.\n */\nfunction getDescriptor<T extends object, K extends keyof T>(\n    target: T, property: K) {\n  let descriptorTarget: object|null = target;\n  let descriptor: TypedPropertyDescriptor<T[K]>|undefined;\n  while (descriptorTarget) {\n    descriptor = Object.getOwnPropertyDescriptor(descriptorTarget, property);\n    if (descriptor) {\n      break;\n    }\n\n    // Walk up the instance's prototype chain in case the property is declared\n    // on a superclass.\n    descriptorTarget = Object.getPrototypeOf(descriptorTarget);\n  }\n\n  return descriptor;\n}\n"]}