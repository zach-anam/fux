{"version":3,"file":"action-controller.js","sourceRoot":"","sources":["action-controller.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ReactiveController, ReactiveControllerHost} from 'lit';\n\n/**\n * Enumeration to keep track of the lifecycle of a touch event.\n */\n\n// State transition diagram:\n//     +-----------------------------+\n//     |                             v\n//     |    +------+------ WAITING_FOR_MOUSE_CLICK<----+\n//     |    |      |                ^                  |\n//     |    V      |                |                  |\n// => INACTIVE -> TOUCH_DELAY -> RELEASING          HOLDING\n//                 |                                   ^\n//                 |                                   |\n//                 +-----------------------------------+\nenum Phase {\n  // Initial state of the control, no touch in progress.\n  // Transitions:\n  //     on touch down: transition to TOUCH_DELAY.\n  //     on mouse down: transition to WAITING_FOR_MOUSE_CLICK.\n  INACTIVE = 'INACTIVE',\n\n  // Touch down has been received, waiting to determine if it's a swipe.\n  // Transitions:\n  //     on touch up: beginPress(); transition to RELEASING.\n  //     on cancel: transition to INACTIVE.\n  //     after TOUCH_DELAY_MS: beginPress(); transition to HOLDING.\n  TOUCH_DELAY = 'TOUCH_DELAY',\n\n  // A touch has been deemed to be a press\n  // Transitions:\n  //     on pointerup: endPress(); transition to WAITING_FOR_MOUSE_CLICK.\n  HOLDING = 'HOLDING',\n\n  // The user has released the mouse / touch, but we want to delay calling\n  // endPress for a little bit to avoid double clicks.\n  // Transitions:\n  //    mouse sequence after debounceDelay: endPress(); transition to INACTIVE\n  //    when in touch sequence: transitions directly to WAITING_FOR_MOUSE_CLICK\n  RELEASING = 'RELEASING',\n\n  // The user has touched, but we want to delay endPress until synthetic mouse\n  // click event occurs. Stay in this state for a fixed amount of time before\n  // giving up and transitioning into rest state.\n  // Transitions:\n  //     on click: endPress(); transition to INACTIVE.\n  //     after WAIT_FOR_MOUSE_CLICK_MS: transition to INACTIVE.\n  WAITING_FOR_MOUSE_CLICK = 'WAITING_FOR_MOUSE_CLICK'\n}\n\n/**\n * Delay time from touchstart to when element#beginPress is invoked.\n */\nexport const TOUCH_DELAY_MS = 150;\n\n/**\n * Delay time from beginning to wait for synthetic mouse events till giving up.\n */\nexport const WAIT_FOR_MOUSE_CLICK_MS = 500;\n\n/**\n * Interface for argument to beginPress.\n */\nexport interface BeginPressConfig {\n  /**\n   * Event that was recorded at the start of the interaction.\n   * `null` if the press happened via keyboard.\n   */\n  positionEvent: Event|null;\n}\n\n/**\n * Interface for argument to endPress.\n */\nexport interface EndPressConfig {\n  /**\n   * `true` if the press was cancelled.\n   */\n  cancelled: boolean;\n  /**\n   * Data object to pass along to clients in the `action` event, if relevant.\n   */\n  actionData?: {};\n}\n\n/**\n * The necessary interface for using an ActionController\n */\nexport interface ActionControllerHost extends ReactiveControllerHost,\n                                              HTMLElement {\n  disabled: boolean;\n  /**\n   * Determines if pointerdown or click events containing modifier keys should\n   * be ignored.\n   */\n  ignoreClicksWithModifiers?: boolean;\n  /**\n   * Called when a user interaction is determined to be a press.\n   */\n  beginPress(config: BeginPressConfig): void;\n  /**\n   * Called when a press ends or is cancelled.\n   */\n  endPress(config: EndPressConfig): void;\n}\n\n/**\n * ActionController normalizes user interaction on components and distills it\n * into calling `beginPress` and `endPress` on the component.\n *\n * `beginPress` is a good hook to affect visuals for pressed state, including\n * ripple.\n *\n * `endPress` is a good hook for firing events based on user interaction, and\n * cleaning up the pressed visual state.\n *\n * A component using an ActionController need only implement the ActionElement\n * interface and add the ActionController's event listeners to understand user\n * interaction.\n */\nexport class ActionController implements ReactiveController {\n  constructor(private readonly element: ActionControllerHost) {\n    this.element.addController(this);\n  }\n\n  private get disabled() {\n    return this.element.disabled;\n  }\n\n  private get ignoreClicksWithModifiers() {\n    return this.element.ignoreClicksWithModifiers ?? false;\n  }\n\n  private phase = Phase.INACTIVE;\n\n  private touchTimer: number|null = null;\n\n  private clickTimer: number|null = null;\n\n  private lastPositionEvent: PointerEvent|null = null;\n\n  private pressed = false;\n\n  private checkBoundsAfterContextMenu = false;\n\n  private setPhase(newPhase: Phase) {\n    this.phase = newPhase;\n  }\n\n  /**\n   * Calls beginPress and then endPress. Allows us to programmatically click\n   * on the element.\n   */\n  private press() {\n    this.beginPress(/* positionEvent= */ null);\n    this.setPhase(Phase.INACTIVE);\n    this.endPress();\n  }\n\n  /**\n   * Call `beginPress` on element with triggering event, if applicable.\n   */\n  private beginPress(positionEvent: Event|null = this.lastPositionEvent) {\n    this.pressed = true;\n    this.element.beginPress({positionEvent});\n  }\n\n  /**\n   * Call `endPress` on element, and clean up timers.\n   */\n  private endPress() {\n    this.pressed = false;\n    this.element.endPress({cancelled: false});\n    this.cleanup();\n  }\n\n  private cleanup() {\n    if (this.touchTimer) {\n      clearTimeout(this.touchTimer);\n    }\n    this.touchTimer = null;\n    if (this.clickTimer) {\n      clearTimeout(this.clickTimer);\n    }\n    this.clickTimer = null;\n    this.lastPositionEvent = null;\n  }\n\n  /**\n   * Call `endPress` with cancelled state on element, and cleanup timers.\n   */\n  private cancelPress() {\n    this.pressed = false;\n    this.cleanup();\n    if (this.phase === Phase.TOUCH_DELAY) {\n      this.setPhase(Phase.INACTIVE);\n    } else if (this.phase !== Phase.INACTIVE) {\n      this.setPhase(Phase.INACTIVE);\n      this.element.endPress({cancelled: true});\n    }\n  }\n\n  private isTouch(e: PointerEvent) {\n    return e.pointerType === 'touch';\n  }\n\n  private touchDelayFinished() {\n    if (this.phase !== Phase.TOUCH_DELAY) {\n      return;\n    }\n    this.setPhase(Phase.HOLDING);\n    this.beginPress();\n  }\n\n  private waitForClick() {\n    this.setPhase(Phase.WAITING_FOR_MOUSE_CLICK);\n    this.clickTimer = setTimeout(() => {\n      // If a click event does not occur, clean up the interaction state.\n      if (this.phase === Phase.WAITING_FOR_MOUSE_CLICK) {\n        this.cancelPress();\n      }\n    }, WAIT_FOR_MOUSE_CLICK_MS);\n  }\n\n  /**\n   * Check if event should trigger actions on the element.\n   */\n  private shouldRespondToEvent(e: PointerEvent) {\n    return !this.disabled && e.isPrimary;\n  }\n\n  /**\n   * Check if the event is within the bounds of the element.\n   *\n   * This is only needed for the \"stuck\" contextmenu longpress on Chrome.\n   */\n  private inBounds(ev: PointerEvent) {\n    const {top, left, bottom, right} = this.element.getBoundingClientRect();\n    const {x, y} = ev;\n    return x >= left && x <= right && y >= top && y <= bottom;\n  }\n\n  private eventHasModifiers(e: MouseEvent) {\n    return e.altKey || e.ctrlKey || e.shiftKey || e.metaKey;\n  }\n\n  /**\n   * Cancel interactions if the element is removed from the DOM.\n   */\n  hostDisconnected() {\n    this.cancelPress();\n  }\n\n  /**\n   * If the element becomes disabled, cancel interactions.\n   */\n  hostUpdated() {\n    if (this.disabled) {\n      this.cancelPress();\n    }\n  }\n\n  // event listeners\n  /**\n   * Pointer down event handler.\n   */\n  pointerDown =\n      (e: PointerEvent) => {\n        if (!this.shouldRespondToEvent(e) || this.phase !== Phase.INACTIVE) {\n          return;\n        }\n        if (this.isTouch(e)) {\n          // after a longpress contextmenu event, an extra `pointerdown` can be\n          // dispatched to the pressed element. Check that the down is within\n          // bounds of the element in this case.\n          if (this.checkBoundsAfterContextMenu && !this.inBounds(e)) {\n            return;\n          }\n          this.checkBoundsAfterContextMenu = false;\n          this.lastPositionEvent = e;\n          this.setPhase(Phase.TOUCH_DELAY);\n          this.touchTimer = setTimeout(() => {\n            this.touchDelayFinished();\n          }, TOUCH_DELAY_MS);\n        } else {\n          const leftButtonPressed = e.button === 0;\n          if (!leftButtonPressed ||\n              (this.ignoreClicksWithModifiers && this.eventHasModifiers(e))) {\n            return;\n          }\n          this.setPhase(Phase.WAITING_FOR_MOUSE_CLICK);\n          this.beginPress(e);\n        }\n      }\n\n  /**\n   * Pointer up event handler.\n   */\n  pointerUp =\n      (e: PointerEvent) => {\n        if (!this.isTouch(e) || !this.shouldRespondToEvent(e)) {\n          return;\n        }\n        if (this.phase === Phase.HOLDING) {\n          this.waitForClick();\n        } else if (this.phase === Phase.TOUCH_DELAY) {\n          this.setPhase(Phase.RELEASING);\n          this.beginPress();\n          this.waitForClick();\n        }\n      }\n\n  /**\n   * Click event handler.\n   */\n  click =\n      (e: MouseEvent) => {\n        if (this.disabled ||\n            (this.ignoreClicksWithModifiers && this.eventHasModifiers(e))) {\n          return;\n        }\n        if (this.phase === Phase.WAITING_FOR_MOUSE_CLICK) {\n          this.endPress();\n          this.setPhase(Phase.INACTIVE);\n          return;\n        }\n\n        // keyboard synthesized click event\n        if (this.phase === Phase.INACTIVE && !this.pressed) {\n          this.press();\n        }\n      }\n\n  /**\n   * Pointer leave event handler.\n   */\n  pointerLeave =\n      (e: PointerEvent) => {\n        // cancel a held press that moves outside the element\n        if (this.shouldRespondToEvent(e) && !this.isTouch(e) && this.pressed) {\n          this.cancelPress();\n        }\n      }\n\n  /**\n   * Pointer cancel event handler.\n   */\n  pointerCancel =\n      (e: PointerEvent) => {\n        if (this.shouldRespondToEvent(e)) {\n          this.cancelPress();\n        }\n      }\n\n  /**\n   * Contextmenu event handler.\n   */\n  contextMenu = () => {\n    if (!this.disabled) {\n      this.checkBoundsAfterContextMenu = true;\n      this.cancelPress();\n    }\n  }\n}\n"]}