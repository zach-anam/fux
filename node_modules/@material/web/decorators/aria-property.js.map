{"version":3,"file":"aria-property.js","sourceRoot":"","sources":["aria-property.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAIH;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,MAAM,UAAU,YAAY,CAExB,SAAY,EAAE,QAAW;IAC3B,0EAA0E;IAC1E,6EAA6E;IAC7E,2EAA2E;IAC3E,mBAAmB;IACnB,MAAM,CAAC,cAAc,CAAC,SAAS,EAAE,QAAQ,EAAE;QACzC,YAAY,EAAE,IAAI;QAClB,UAAU,EAAE,IAAI;QAChB,GAAG;YACD,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;QACtC,CAAC;QACD,GAAG,CAAwB,KAAc;YACvC,uCAAuC;YACvC,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;YACrC,IAAI,QAAQ,EAAE;gBACZ,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC;aACnC;iBAAM;gBACL,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;aAC/B;YAED,mEAAmE;YACnE,uEAAuE;YACvE,uEAAuE;YACvE,iBAAiB;YACjB,IAAI,CAAC,aAAa,EAAE,CAAC;QACvB,CAAC;KACF,CAAC,CAAC;IAEH,8EAA8E;IAC9E,yEAAyE;IACzE,8EAA8E;IAC9E,wEAAwE;IACxE,MAAM,oBAAoB,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC9C,sEAAsE;IACtE,MAAM,aAAa,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,WAAW,EAAE,CAAC;IACtE,MAAM,WAAW,GAAI,SAAS,CAAC,WAAsC,CAAC;IACtE,IAAI,iBAAiB,GAAG,KAAK,CAAC;IAC9B,MAAM,CAAC,cAAc,CAAC,SAAS,EAAE,oBAAoB,EAAE;QACrD,GAAG;YACD,+DAA+D;YAC/D,4CAA4C;YAC5C,yDAAyD;YACzD,OAAQ,IAAU,CAAC,QAAQ,CAAC,CAAC;QAC/B,CAAC;QACD,GAAG,CAAwB,KAAW;YACpC,IAAI,iBAAiB,EAAE;gBACrB,+CAA+C;gBAC/C,OAAO;aACR;YAED,qEAAqE;YACrE,8CAA8C;YAC9C,+DAA+D;YAC/D,4CAA4C;YAC5C,yDAAyD;YACxD,IAAU,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;YAC9B,wEAAwE;YACxE,6CAA6C;YAC7C,iBAAiB,GAAG,IAAI,CAAC;YACzB,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;YACpC,iBAAiB,GAAG,KAAK,CAAC;QAC5B,CAAC;KACF,CAAC,CAAC;IAEH,4EAA4E;IAC5E,uDAAuD;IACvD,WAAW,CAAC,cAAc,CAAC,oBAAoB,EAAE;QAC/C,SAAS,EAAE,aAAa;QACxB,UAAU,EAAE,IAAI;KACjB,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ReactiveElement} from 'lit';\n\n/**\n * A property decorator that helps proxy an aria attribute to an internal node.\n *\n * This decorator is only intended for use with ARIAMixin properties,\n * such as `ariaLabel`, to help with screen readers.\n *\n * This decorator will remove the host `aria-*` attribute at runtime and add it\n * to a `data-aria-*` attribute to avoid screenreader conflicts between the\n * host and internal node.\n *\n * `@ariaProperty` decorated properties should sync with LitElement to the\n * `data-aria-*` attribute, not the native `aria-*` attribute.\n *\n * @example\n * ```ts\n * class MyElement extends LitElement {\n *   \\@ariaProperty\n *   // TODO(b/210730484): replace with @soyParam annotation\n *   \\@property({ type: String, attribute: 'data-aria-label', noAccessor: true})\n *   ariaLabel!: string;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function ariaProperty<E extends ReactiveElement, K extends keyof E&\n                             (`aria${string}` | 'role')>(\n    prototype: E, property: K) {\n  // Replace the ARIAMixin property with data-* attribute syncing instead of\n  // using the native aria-* attribute reflection. This preserves the attribute\n  // for SSR and avoids screenreader conflicts after delegating the attribute\n  // to a child node.\n  Object.defineProperty(prototype, property, {\n    configurable: true,\n    enumerable: true,\n    get(this: ReactiveElement) {\n      return this.dataset[property] ?? '';\n    },\n    set(this: ReactiveElement, value: unknown) {\n      // Coerce non-string values to a string\n      const strValue = String(value ?? '');\n      if (strValue) {\n        this.dataset[property] = strValue;\n      } else {\n        delete this.dataset[property];\n      }\n\n      // lit will call this setter whenever the data-* attribute changes.\n      // However, this.dataset[property] will automatically be updated to the\n      // current value. To avoid bugs, always request an update regardless of\n      // the old value.\n      this.requestUpdate();\n    }\n  });\n\n  // Define an internal property that syncs from the `aria-*` attribute with lit\n  // and delegates to the real ARIAMixin property, which renders an update.\n  // This property will immediately remove the `aria-*` attribute, which doesn't\n  // work well with SSR (which is why there's a separate synced property).\n  const internalAriaProperty = Symbol(property);\n  // \"ariaLabel\" -> \"aria-label\" / \"ariaLabelledBy\" -> \"aria-labelledby\"\n  const ariaAttribute = property.replace('aria', 'aria-').toLowerCase();\n  const constructor = (prototype.constructor as typeof ReactiveElement);\n  let removingAttribute = false;\n  Object.defineProperty(prototype, internalAriaProperty, {\n    get(this: ReactiveElement) {\n      // tslint is failing here, but the types are correct (ARIAMixin\n      // properties do not obfuscate with closure)\n      // tslint:disable-next-line:no-dict-access-on-struct-type\n      return (this as E)[property];\n    },\n    set(this: ReactiveElement, value: E[K]) {\n      if (removingAttribute) {\n        // Ignore this update, which is triggered below\n        return;\n      }\n\n      // Set the ARIAMixin property, which will sync the `data-*` attribute\n      // and trigger rendering if the value changed.\n      // tslint is failing here, but the types are correct (ARIAMixin\n      // properties do not obfuscate with closure)\n      // tslint:disable-next-line:no-dict-access-on-struct-type\n      (this as E)[property] = value;\n      // Remove the `aria-*` attribute, which will call this setter again with\n      // the incorrect value. Ignore these updates.\n      removingAttribute = true;\n      this.removeAttribute(ariaAttribute);\n      removingAttribute = false;\n    }\n  });\n\n  // Tell lit to observe the `aria-*` attribute and set the internal property,\n  // which acts as a \"aria-* attribute changed\" observer.\n  constructor.createProperty(internalAriaProperty, {\n    attribute: ariaAttribute,\n    noAccessor: true,\n  });\n}\n"]}