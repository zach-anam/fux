{"version":3,"file":"directive.js","sourceRoot":"","sources":["directive.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {noChange} from 'lit';\nimport {Directive, directive, DirectiveParameters, ElementPart, PartInfo, PartType} from 'lit/directive.js';\n\nimport {Ripple} from './lib/ripple.js';\n\n/**\n * Delay reacting to touch so that we do not show the ripple for a swipe or\n * scroll interaction.\n */\nconst TOUCH_DELAY_MS = 150;\n\n/**\n * Interaction states for the ripple.\n *\n * On Touch:\n *  - `INACTIVE -> TOUCH_DELAY -> WAITING_FOR_CLICK -> INACTIVE`\n *  - `INACTIVE -> TOUCH_DELAY -> HOLDING -> WAITING_FOR_CLICK -> INACTIVE`\n *\n * On Mouse or Pen:\n *   - `INACTIVE -> WAITING_FOR_CLICK -> INACTIVE`\n */\nenum State {\n  /**\n   * Initial state of the control, no touch in progress.\n   *\n   * Transitions:\n   *   - on touch down: transition to `TOUCH_DELAY`.\n   *   - on mouse down: transition to `WAITING_FOR_CLICK`.\n   */\n  INACTIVE,\n  /**\n   * Touch down has been received, waiting to determine if it's a swipe or\n   * scroll.\n   *\n   * Transitions:\n   *   - on touch up: beginPress(); transition to `WAITING_FOR_CLICK`.\n   *   - on cancel: transition to `INACTIVE`.\n   *   - after `TOUCH_DELAY_MS`: beginPress(); transition to `HOLDING`.\n   */\n  TOUCH_DELAY,\n  /**\n   * A touch has been deemed to be a press\n   *\n   * Transitions:\n   *  - on up: transition to `WAITING_FOR_CLICK`.\n   */\n  HOLDING,\n  /**\n   * The user touch has finished, transition into rest state.\n   *\n   * Transitions:\n   *   - on click endPress(); transition to `INACTIVE`.\n   */\n  WAITING_FOR_CLICK\n}\n\n/**\n * Normalized ripple accessor type.\n *\n * Use with `await rippleFunction()`\n */\ntype RippleFunction = () => Ripple|null|Promise<Ripple|null>;\n\nclass RippleDirective extends Directive {\n  private rippleGetter: RippleFunction = async () => null;\n  private element?: HTMLElement;\n  private state: State = State.INACTIVE;\n  private checkBoundsAfterContextMenu = false;\n  private rippleStartEvent: PointerEvent|null = null;\n  private touchTimer: number|null = null;\n  private clickTimer: number|null = null;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.ELEMENT) {\n      throw new Error('The `ripple` directive must be used on an element');\n    }\n  }\n\n  render(ripple: RippleFunction|Promise<Ripple|null>) {\n    return noChange;\n  }\n\n  // Use EventListenerObject::handleEvent interface to handle events without\n  // generating bound event handlers\n  async handleEvent(event: Event) {\n    const ripple = await this.rippleGetter();\n    if (!ripple) {\n      return;\n    }\n    switch (event.type) {\n      case 'click':\n        this.click(ripple);\n        break;\n      case 'contextmenu':\n        this.contextMenu(ripple);\n        break;\n      case 'pointercancel':\n        this.pointerCancel(ripple, event as PointerEvent);\n        break;\n      case 'pointerdown':\n        this.pointerDown(ripple, event as PointerEvent);\n        break;\n      case 'pointerenter':\n        this.pointerEnter(ripple, event as PointerEvent);\n        break;\n      case 'pointerleave':\n        this.pointerLeave(ripple, event as PointerEvent);\n        break;\n      case 'pointerup':\n        this.pointerUp(ripple, event as PointerEvent);\n        break;\n      default:\n        break;\n    }\n  }\n\n  override update(part: ElementPart, [ripple]: DirectiveParameters<this>) {\n    if (!this.element) {\n      // NOTE: addEventListener typing needs to be used with HTMLElements or a\n      // subclass\n      this.element = part.element as HTMLElement;\n      this.element.addEventListener('click', this);\n      this.element.addEventListener('contextmenu', this);\n      this.element.addEventListener('pointercancel', this);\n      this.element.addEventListener('pointerdown', this);\n      this.element.addEventListener('pointerenter', this);\n      this.element.addEventListener('pointerleave', this);\n      this.element.addEventListener('pointerup', this);\n    }\n    // Normalize given ripple accessor\n    this.rippleGetter = typeof ripple === 'function' ? ripple : () => ripple;\n    return noChange;\n  }\n\n  /**\n   * Returns `true` if\n   *  - the ripple element is enabled\n   *  - the pointer is primary for the input type\n   *  - the pointer is the pointer that started the interaction, or will start\n   * the interaction\n   *  - the pointer is a touch, or the pointer state has the primary button\n   * held, or the pointer is hovering\n   */\n  private shouldReactToEvent(\n      ripple: Ripple, ev: PointerEvent, hovering = false) {\n    const enabled = !ripple.disabled;\n    const isPrimaryPointer = ev.isPrimary;\n    const isInteractionPointer = this.rippleStartEvent === null ||\n        this.rippleStartEvent.pointerId === ev.pointerId;\n    const isPrimaryButton = ev.buttons === 1;\n    return enabled && isPrimaryPointer && isInteractionPointer &&\n        (this.isTouch(ev) || isPrimaryButton || hovering);\n  }\n\n  private isTouch({pointerType}: PointerEvent) {\n    return pointerType === 'touch';\n  }\n\n  /**\n   * Check if the event is within the bounds of the element.\n   *\n   * This is only needed for the \"stuck\" contextmenu longpress on Chrome.\n   */\n  private inBounds({x, y}: PointerEvent) {\n    const {top, left, bottom, right} = this.element!.getBoundingClientRect();\n    return x >= left && x <= right && y >= top && y <= bottom;\n  }\n\n  private beginPress(ripple: Ripple) {\n    ripple.beginPress(this.rippleStartEvent);\n  }\n\n  private endPress(ripple: Ripple) {\n    ripple.endPress();\n    this.state = State.INACTIVE;\n    this.rippleStartEvent = null;\n    if (this.touchTimer) {\n      clearTimeout(this.touchTimer);\n      this.touchTimer = null;\n    }\n    if (this.clickTimer) {\n      clearTimeout(this.clickTimer);\n      this.clickTimer = null;\n    }\n  }\n\n  private waitForTouchHold() {\n    if (this.touchTimer !== null) {\n      clearTimeout(this.touchTimer);\n    }\n    this.state = State.TOUCH_DELAY;\n    this.touchTimer = setTimeout(async () => {\n      const ripple = await this.rippleGetter();\n      if (ripple === null || this.state !== State.TOUCH_DELAY) {\n        return;\n      }\n      this.state = State.HOLDING;\n      this.beginPress(ripple);\n    }, TOUCH_DELAY_MS);\n  }\n\n  private click(ripple: Ripple) {\n    // Click is a MouseEvent in Firefox and Safari, so we cannot use\n    // `shouldReactToEvent`\n    if (ripple.disabled) {\n      return;\n    }\n    if (this.state === State.WAITING_FOR_CLICK) {\n      this.endPress(ripple);\n    } else if (this.state === State.INACTIVE) {\n      // keyboard synthesized click event\n      this.beginPress(ripple);\n      this.endPress(ripple);\n    }\n  }\n\n  private contextMenu(ripple: Ripple) {\n    if (!ripple.disabled) {\n      this.checkBoundsAfterContextMenu = true;\n      this.endPress(ripple);\n    }\n  }\n\n  private pointerDown(ripple: Ripple, ev: PointerEvent) {\n    if (!this.shouldReactToEvent(ripple, ev)) {\n      return;\n    }\n    this.rippleStartEvent = ev;\n    if (this.isTouch(ev)) {\n      // after a longpress contextmenu event, an extra `pointerdown` can be\n      // dispatched to the pressed element. Check that the down is within\n      // bounds of the element in this case.\n      if (this.checkBoundsAfterContextMenu && !this.inBounds(ev)) {\n        return;\n      }\n      this.checkBoundsAfterContextMenu = false;\n      this.waitForTouchHold();\n    } else {\n      this.state = State.WAITING_FOR_CLICK;\n      this.beginPress(ripple);\n    }\n  }\n\n  private pointerUp(ripple: Ripple, ev: PointerEvent) {\n    if (!this.isTouch(ev) || !this.shouldReactToEvent(ripple, ev)) {\n      return;\n    }\n    if (this.state === State.HOLDING) {\n      this.state = State.WAITING_FOR_CLICK;\n    } else if (this.state === State.TOUCH_DELAY) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.beginPress(ripple);\n    }\n  }\n\n  private pointerCancel(ripple: Ripple, ev: PointerEvent) {\n    if (this.shouldReactToEvent(ripple, ev)) {\n      this.endPress(ripple);\n    }\n  }\n\n  private pointerEnter(ripple: Ripple, ev: PointerEvent) {\n    if (this.shouldReactToEvent(ripple, ev, true)) {\n      ripple.beginHover(ev);\n    }\n  }\n\n  private pointerLeave(ripple: Ripple, ev: PointerEvent) {\n    if (this.shouldReactToEvent(ripple, ev, true)) {\n      ripple.endHover();\n      // release a held mouse or pen press that moves outside the element\n      if (!this.isTouch(ev) && this.state !== State.INACTIVE) {\n        this.endPress(ripple);\n      }\n    }\n  }\n}\n\n/**\n * Connects a Ripple element to a node that drives the interaction\n *\n * @param rippleGetter A function that returns an `md-ripple` element\n * @param simulateKeyboardClick For elements that do not issue a click on\n *     keyboard interaction, pass `true` to enable press animations on Enter or\n *     Spacebar\n */\nexport const ripple = directive(RippleDirective);"]}