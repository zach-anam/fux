{"version":3,"file":"foundation.js","sourceRoot":"","sources":["foundation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {MDCChipActionFocusBehavior, MDCChipActionType} from '../../action/lib/constants.js';\nimport {MDCChipAnimation} from '../../chip/lib/constants.js';\n\nimport {MDCChipSetAdapter} from './adapter.js';\nimport {MDCChipSetAttributes, MDCChipSetEvents} from './constants.js';\nimport {ChipAnimationEvent, ChipInteractionEvent, ChipNavigationEvent, MDCChipSetInteractionEventDetail, MDCChipSetRemovalEventDetail, MDCChipSetSelectionEventDetail} from './types.js';\n\ninterface FocusAction {\n  action: MDCChipActionType;\n  index: number;\n}\n\nenum Operator {\n  INCREMENT,\n  DECREMENT,\n}\n\n/**\n * MDCChipSetFoundation provides a foundation for all chips.\n */\nexport class MDCChipSetFoundation {\n  private readonly adapter: MDCChipSetAdapter;\n\n  static get defaultAdapter(): MDCChipSetAdapter {\n    return {\n      announceMessage: () => undefined,\n      emitEvent: () => undefined,\n      getAttribute: () => null,\n      getChipActionsAtIndex: () => [],\n      getChipCount: () => 0,\n      getChipIdAtIndex: () => '',\n      getChipIndexById: () => 0,\n      isChipFocusableAtIndex: () => false,\n      isChipSelectableAtIndex: () => false,\n      isChipSelectedAtIndex: () => false,\n      removeChipAtIndex: () => {},\n      setChipFocusAtIndex: () => undefined,\n      setChipSelectedAtIndex: () => undefined,\n      startChipAnimationAtIndex: () => undefined,\n    };\n  }\n\n  constructor(adapter?: Partial<MDCChipSetAdapter>) {\n    this.adapter = {...MDCChipSetFoundation.defaultAdapter, ...adapter};\n  }\n\n  handleChipAnimation({detail}: ChipAnimationEvent) {\n    const {\n      chipID,\n      animation,\n      isComplete,\n      addedAnnouncement,\n      removedAnnouncement\n    } = detail;\n    const index = this.adapter.getChipIndexById(chipID);\n\n    if (animation === MDCChipAnimation.EXIT && isComplete) {\n      if (removedAnnouncement) {\n        this.adapter.announceMessage(removedAnnouncement);\n      }\n      this.removeAfterAnimation(index, chipID);\n      return;\n    }\n\n    if (animation === MDCChipAnimation.ENTER && isComplete &&\n        addedAnnouncement) {\n      this.adapter.announceMessage(addedAnnouncement);\n      return;\n    }\n  }\n\n  handleChipInteraction({detail}: ChipInteractionEvent) {\n    const {source, chipID, isSelectable, isSelected, shouldRemove} = detail;\n    const index = this.adapter.getChipIndexById(chipID);\n\n    if (shouldRemove) {\n      this.removeChip(index);\n      return;\n    }\n\n    this.focusChip(index, source, MDCChipActionFocusBehavior.FOCUSABLE);\n    this.adapter.emitEvent<MDCChipSetInteractionEventDetail>(\n        MDCChipSetEvents.INTERACTION, {\n          chipIndex: index,\n          chipID,\n        });\n\n    if (isSelectable) {\n      this.setSelection(index, source, !isSelected);\n    }\n  }\n\n  handleChipNavigation({detail}: ChipNavigationEvent) {\n    const {chipID, key, isRTL, source} = detail;\n    const index = this.adapter.getChipIndexById(chipID);\n\n    const toNextChip =\n        (key === 'ArrowRight' && !isRTL) || (key === 'ArrowLeft' && isRTL);\n    if (toNextChip) {\n      // Start from the next chip so we increment the index\n      this.focusNextChipFrom(index + 1);\n      return;\n    }\n\n    const toPreviousChip =\n        (key === 'ArrowLeft' && !isRTL) || (key === 'ArrowRight' && isRTL);\n    if (toPreviousChip) {\n      // Start from the previous chip so we decrement the index\n      this.focusPrevChipFrom(index - 1);\n      return;\n    }\n\n    if (key === 'ArrowDown') {\n      // Start from the next chip so we increment the index\n      this.focusNextChipFrom(index + 1, source);\n      return;\n    }\n\n    if (key === 'ArrowUp') {\n      // Start from the previous chip so we decrement the index\n      this.focusPrevChipFrom(index - 1, source);\n      return;\n    }\n\n    if (key === 'Home') {\n      this.focusNextChipFrom(0, source);\n      return;\n    }\n\n    if (key === 'End') {\n      this.focusPrevChipFrom(this.adapter.getChipCount() - 1, source);\n      return;\n    }\n  }\n\n  /** Returns the unique selected indexes of the chips. */\n  getSelectedChipIndexes(): ReadonlySet<number> {\n    const selectedIndexes = new Set<number>();\n    const chipCount = this.adapter.getChipCount();\n    for (let i = 0; i < chipCount; i++) {\n      const actions = this.adapter.getChipActionsAtIndex(i);\n      for (const action of actions) {\n        if (this.adapter.isChipSelectedAtIndex(i, action)) {\n          selectedIndexes.add(i);\n        }\n      }\n    }\n    return selectedIndexes;\n  }\n\n  /** Sets the selected state of the chip at the given index and action. */\n  setChipSelected(\n      index: number, action: MDCChipActionType, isSelected: boolean) {\n    if (this.adapter.isChipSelectableAtIndex(index, action)) {\n      this.setSelection(index, action, isSelected);\n    }\n  }\n\n  /** Returns the selected state of the chip at the given index and action. */\n  isChipSelected(index: number, action: MDCChipActionType): boolean {\n    return this.adapter.isChipSelectedAtIndex(index, action);\n  }\n\n  /** Removes the chip at the given index. */\n  removeChip(index: number) {\n    // Early exit if the index is out of bounds\n    if (index >= this.adapter.getChipCount() || index < 0) return;\n    this.adapter.startChipAnimationAtIndex(index, MDCChipAnimation.EXIT);\n    this.adapter.emitEvent<MDCChipSetRemovalEventDetail>(\n        MDCChipSetEvents.REMOVAL, {\n          chipID: this.adapter.getChipIdAtIndex(index),\n          chipIndex: index,\n          isComplete: false,\n        });\n  }\n\n  addChip(index: number) {\n    // Early exit if the index is out of bounds\n    if (index >= this.adapter.getChipCount() || index < 0) return;\n    this.adapter.startChipAnimationAtIndex(index, MDCChipAnimation.ENTER);\n  }\n\n  /**\n   * Increments to find the first focusable chip.\n   */\n  private focusNextChipFrom(\n      startIndex: number, targetAction?: MDCChipActionType) {\n    const chipCount = this.adapter.getChipCount();\n    for (let i = startIndex; i < chipCount; i++) {\n      const focusableAction =\n          this.getFocusableAction(i, Operator.INCREMENT, targetAction);\n      if (focusableAction) {\n        this.focusChip(\n            i, focusableAction,\n            MDCChipActionFocusBehavior.FOCUSABLE_AND_FOCUSED);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Decrements to find the first focusable chip. Takes an optional target\n   * action that can be used to focus the first matching focusable action.\n   */\n  private focusPrevChipFrom(\n      startIndex: number, targetAction?: MDCChipActionType) {\n    for (let i = startIndex; i > -1; i--) {\n      const focusableAction =\n          this.getFocusableAction(i, Operator.DECREMENT, targetAction);\n      if (focusableAction) {\n        this.focusChip(\n            i, focusableAction,\n            MDCChipActionFocusBehavior.FOCUSABLE_AND_FOCUSED);\n        return;\n      }\n    }\n  }\n\n  /** Returns the appropriate focusable action, or null if none exist. */\n  private getFocusableAction(\n      index: number, op: Operator,\n      targetAction?: MDCChipActionType): MDCChipActionType|null {\n    const actions = this.adapter.getChipActionsAtIndex(index);\n    // Reverse the actions if decrementing\n    if (op === Operator.DECREMENT) actions.reverse();\n\n    if (targetAction) {\n      return this.getMatchingFocusableAction(index, actions, targetAction);\n    }\n\n    return this.getFirstFocusableAction(index, actions);\n  }\n\n  /**\n   * Returs the first focusable action, regardless of type, or null if no\n   * focusable actions exist.\n   */\n  private getFirstFocusableAction(index: number, actions: MDCChipActionType[]):\n      MDCChipActionType|null {\n    for (const action of actions) {\n      if (this.adapter.isChipFocusableAtIndex(index, action)) {\n        return action;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * If the actions contain a focusable action that matches the target action,\n   * return that. Otherwise, return the first focusable action, or null if no\n   * focusable action exists.\n   */\n  private getMatchingFocusableAction(\n      index: number, actions: MDCChipActionType[],\n      targetAction: MDCChipActionType): MDCChipActionType|null {\n    let focusableAction = null;\n    for (const action of actions) {\n      if (this.adapter.isChipFocusableAtIndex(index, action)) {\n        focusableAction = action;\n      }\n\n      // Exit and return the focusable action if it matches the target\n      if (focusableAction === targetAction) {\n        return focusableAction;\n      }\n    }\n    return focusableAction;\n  }\n\n  private focusChip(\n      index: number, action: MDCChipActionType,\n      focus: MDCChipActionFocusBehavior) {\n    this.adapter.setChipFocusAtIndex(index, action, focus);\n    const chipCount = this.adapter.getChipCount();\n    for (let i = 0; i < chipCount; i++) {\n      const actions = this.adapter.getChipActionsAtIndex(i);\n      for (const chipAction of actions) {\n        // Skip the action and index provided since we set it above\n        if (chipAction === action && i === index) continue;\n        this.adapter.setChipFocusAtIndex(\n            i, chipAction, MDCChipActionFocusBehavior.NOT_FOCUSABLE);\n      }\n    }\n  }\n\n  private supportsMultiSelect(): boolean {\n    return this.adapter.getAttribute(\n               MDCChipSetAttributes.ARIA_MULTISELECTABLE) === 'true';\n  }\n\n  private setSelection(\n      index: number, action: MDCChipActionType, isSelected: boolean) {\n    this.adapter.setChipSelectedAtIndex(index, action, isSelected);\n    this.adapter.emitEvent<MDCChipSetSelectionEventDetail>(\n        MDCChipSetEvents.SELECTION, {\n          chipID: this.adapter.getChipIdAtIndex(index),\n          chipIndex: index,\n          isSelected,\n        });\n    // Early exit if we support multi-selection\n    if (this.supportsMultiSelect()) {\n      return;\n    }\n\n    // If we get here, we ony support single selection. This means we need to\n    // unselect all chips\n    const chipCount = this.adapter.getChipCount();\n    for (let i = 0; i < chipCount; i++) {\n      const actions = this.adapter.getChipActionsAtIndex(i);\n      for (const chipAction of actions) {\n        // Skip the action and index provided since we set it above\n        if (chipAction === action && i === index) continue;\n        this.adapter.setChipSelectedAtIndex(i, chipAction, false);\n      }\n    }\n  }\n\n  private removeAfterAnimation(index: number, chipID: string) {\n    this.adapter.removeChipAtIndex(index);\n    this.adapter.emitEvent<MDCChipSetRemovalEventDetail>(\n        MDCChipSetEvents.REMOVAL, {\n          chipIndex: index,\n          isComplete: true,\n          chipID,\n        });\n\n    const chipCount = this.adapter.getChipCount();\n    // Early exit if we have an empty chip set\n    if (chipCount <= 0) return;\n    this.focusNearestFocusableAction(index);\n  }\n\n  /**\n   * Find the first focusable action by moving bidirectionally horizontally\n   * from the start index.\n   *\n   * Given chip set [A, B, C, D, E, F, G]...\n   * Let's say we remove chip \"F\". We don't know where the nearest focusable\n   * action is since any of them could be disabled. The nearest focusable\n   * action could be E, it could be G, it could even be A. To find it, we\n   * start from the source index (5 for \"F\" in this case) and move out\n   * horizontally, checking each chip at each index.\n   *\n   */\n  private focusNearestFocusableAction(index: number) {\n    const chipCount = this.adapter.getChipCount();\n    let decrIndex = index;\n    let incrIndex = index;\n    while (decrIndex > -1 || incrIndex < chipCount) {\n      const focusAction = this.getNearestFocusableAction(\n          decrIndex, incrIndex, MDCChipActionType.TRAILING);\n      if (focusAction) {\n        this.focusChip(\n            focusAction.index, focusAction.action,\n            MDCChipActionFocusBehavior.FOCUSABLE_AND_FOCUSED);\n        return;\n      }\n\n      decrIndex--;\n      incrIndex++;\n    }\n  }\n\n  private getNearestFocusableAction(\n      decrIndex: number, incrIndex: number,\n      actionType?: MDCChipActionType): FocusAction|null {\n    const decrAction =\n        this.getFocusableAction(decrIndex, Operator.DECREMENT, actionType);\n    if (decrAction) {\n      return {\n        index: decrIndex,\n        action: decrAction,\n      };\n    }\n\n    // Early exit if the incremented and decremented indices are identical\n    if (incrIndex === decrIndex) return null;\n\n    const incrAction =\n        this.getFocusableAction(incrIndex, Operator.INCREMENT, actionType);\n    if (incrAction) {\n      return {\n        index: incrIndex,\n        action: incrAction,\n      };\n    }\n\n    return null;\n  }\n}\n"]}